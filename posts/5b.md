---
title: 5B
published_at: 2025-3-04
snippet: 
disable_html_sanitization: true
allow_math: true
---

# Sabato Visconti’s flower
Sabato Visconti is renowned for his glitch art, where he manipulates digital images to produce unexpected visual distortions. Visconti takes a familiar symbol—the flower—and subjects it to digital corruption, resulting in a mesmerizing loop of fragmented visuals.

# Aesthetic Register and Effective Complexity
The glitching of the 3D flower disrupts our perception, introducing a layer of complexity that challenges the viewer's expectations. This aligns with the concept of "effective complexity," where a balance between order and randomness creates a compelling aesthetic experience. The interplay of recognizable forms with chaotic distortions engages the viewer in a dynamic visual dialogue.

# Technical Underpinnings
Under the hood, such glitch effects can be achieved through various techniques:

- Data Manipulation: Altering the raw data of image files to introduce errors.
- Shader Programming: Utilizing fragment shaders to distort textures in real-time.
- Post-Processing Effects: Applying effects like RGB shifts or noise overlays in rendering pipelines.


# Three.js import
<div id="three_teapot"></div>

<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';
  import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/controls/OrbitControls.js';
  import { TeapotGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/geometries/TeapotGeometry.js';

  const container = document.getElementById("three_teapot");
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 10000);
  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);

  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(10, 10, 10);
  scene.add(light);

  const geometry = new TeapotGeometry(100, 10, true, true, true, false, true);
  const material = new THREE.MeshNormalMaterial({ flatShading: true, side: THREE.DoubleSide });
  const teapot = new THREE.Mesh(geometry, material);
  scene.add(teapot);

  const controls = new OrbitControls(camera, renderer.domElement);
  camera.position.set(200, 150, 300);
  controls.update();

  function animate() {
    requestAnimationFrame(animate);
    teapot.rotation.y += 0.01;
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
